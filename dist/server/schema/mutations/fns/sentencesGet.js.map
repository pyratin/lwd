{"version":3,"sources":["../../../../../js/server/schema/mutations/fns/sentencesGet.js"],"names":["sentenceNormalizeRegExp","_sentenceShortenedGetFn","_sentence","words","reduce","memo","tag","text","match","Set","sentence","word","replace","RegExp","trim","sentenceShortenedGetFn","sentenceShortenedGet","sentenceMaxLength","split","__sentence","length","join","sentenceParenthesisHandle","sentencesPreprocessedGetFn","sentencesPreprocessedGet","sentences","sentenceNormalizedGetFn","joinString","_text","sentenceNormalizedGet","texts","sentenceNormalized","slice","index","paragraph"],"mappings":"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","sourcesContent":["'use strict';\n\nimport sentencesTokenizedGet from './sentencesTokenizedGet';\nimport wordsTokenizedGet from './wordsTokenizedGet';\nimport wordsTaggedGet from './wordsTaggedGet';\nimport parenthesisPurgedGet from './parenthesisPurgedGet';\n\nconst sentenceNormalizeRegExp = /,\\s/;\n\nconst _sentenceShortenedGetFn = (\n  _sentence\n) => {\n\n  let words = wordsTokenizedGet(\n    _sentence\n  );\n\n  words = wordsTaggedGet(\n    words\n  ); \n\n  words = words.reduce(\n    (\n      memo,\n      {\n        tag,\n        text\n      }\n    ) => {\n\n      if (\n        (\n          tag === \n          'CC'\n        ) ||\n        (\n          (\n            tag === \n            'VBG'\n          ) &&\n          (\n            text.match(\n              /ing$/\n            )\n          )\n        )\n      ) {\n\n        return [\n          ...new Set(\n            [\n              ...memo,\n              text\n            ]\n          )\n        ];\n      }\n\n      return (\n        memo\n      );\n    },\n    []\n  );\n\n  const sentence = words.reduce(\n    (\n      memo,\n      word\n    ) => {\n\n      return memo.replace(\n        new RegExp(\n          `\n            ,*\\\\s${\n              word\n            }(\\\\s)\n          `\n            .trim(),\n          'g'\n        ),\n        `\n          , ${\n            word\n          }$1\n        `\n          .trim()\n      );\n    },\n    _sentence\n  );\n\n  return (\n    sentence\n  );\n};\n\nconst sentenceShortenedGetFn = (\n  _sentence\n) => {\n\n  let sentence = _sentenceShortenedGetFn(\n    _sentence\n  );\n\n  sentence = sentence.replace(\n    /\\swhich(\\s)/g,\n    ', which$1'\n  );\n\n  return (\n    sentence\n  );\n};\n\nconst sentenceShortenedGet = (\n  _sentence,\n  sentenceMaxLength\n) => {\n\n  const sentence = _sentence.split(\n    sentenceNormalizeRegExp\n  )\n    .reduce(\n      (\n        memo,\n        __sentence\n      ) => {\n\n        let sentence = __sentence.trim();\n\n        if (\n          sentence.length >\n          sentenceMaxLength\n        ) {\n\n          sentence = sentenceShortenedGetFn(\n            sentence\n          );\n\n          return [\n            ...memo,\n            sentence\n          ];\n        }\n\n        return [\n          ...memo,\n          sentence\n        ];\n      },\n      []\n    )\n    .join(\n      ', '\n    );\n\n  return (\n    sentence\n  );\n};\n\nconst sentenceParenthesisHandle = (\n  _sentence\n) => {\n\n  let sentence = parenthesisPurgedGet(\n    _sentence\n  );\n\n  return (\n    sentence\n  );\n};\n\nconst sentencesPreprocessedGetFn = (\n  _sentence,\n  sentenceMaxLength\n) => {\n\n  let sentence = sentenceShortenedGet(\n    _sentence,\n    sentenceMaxLength\n  );\n\n  sentence = sentenceParenthesisHandle(\n    sentence\n  );\n\n  return (\n    sentence\n  );\n};\n\nconst sentencesPreprocessedGet = (\n  sentences,\n  sentenceMaxLength\n) => {\n\n  return sentences.reduce(\n    (\n      memo,\n      _sentence\n    ) => {\n\n      const sentence = sentencesPreprocessedGetFn(\n        _sentence,\n        sentenceMaxLength\n      );\n\n      if (\n        sentence.trim()\n      ) {\n\n        return [\n          ...memo,\n          sentence\n        ];\n      }\n\n      return (\n        memo\n      );\n    },\n    []\n  );\n};\n\nconst sentenceNormalizedGetFn = (\n  text,\n  sentenceMaxLength\n) => {\n\n  const joinString = ', ';\n\n  return text\n    .split(\n      sentenceNormalizeRegExp\n    )\n    .reduce(\n      (\n        memo,\n        _text\n      ) => {\n\n        switch (\n          true\n        ) {\n\n          case (\n            !memo.length\n          ) :\n\n            return [\n              _text\n            ];\n\n          case (\n            (\n              memo.length < \n              2\n            ) &&\n            (\n              memo[\n                0\n              ]\n                .length +\n              _text.length +\n              +joinString.length\n            ) < \n            sentenceMaxLength\n          ) :\n\n            return [\n              `\n                ${\n                  memo[\n                    0\n                  ]\n                    .trim()\n                }${\n                  joinString\n                }${\n                  _text.trim()\n                }\n              `\n                .trim()\n            ];\n\n          case (\n            memo.length < 2\n          ) :\n\n            return [\n              memo[\n                0\n              ],\n              _text.trim()\n            ];\n\n          default:\n\n            return [\n              memo[\n                0\n              ],\n              `\n                ${\n                  memo[\n                    1\n                  ]\n                    .trim()\n                }${\n                  joinString\n                }${\n                  _text.trim()\n                }\n              `\n                .trim()\n            ];\n        }\n      },\n      []\n    );\n};\n\nconst sentenceNormalizedGet = (\n  text,\n  sentenceMaxLength\n) => {\n\n  let texts = [\n    text\n  ];\n\n  while (\n    (\n      (\n        texts[\n          texts.length - 1\n        ]\n          .length\n      ) >\n      sentenceMaxLength\n    ) &&\n    (\n      !!texts[\n        texts.length -1\n      ]\n        .match(\n          sentenceNormalizeRegExp \n        )\n    )\n  ) {\n\n    const sentenceNormalized = sentenceNormalizedGetFn(\n      texts[\n        texts.length - 1\n      ],\n      sentenceMaxLength\n    );\n\n    texts = [\n      ...texts.slice(\n        0, -1\n      ),\n      ...sentenceNormalized\n    ];\n  }\n\n  texts = texts.reduce(\n    (\n      memo,\n      text,\n      index\n    ) => {\n\n      if (\n        index <\n        (\n          texts.length - 1\n        )\n      ) {\n\n        return [\n          ...memo,\n          `\n            ${\n            text\n            } ...,\n          `\n            .trim()\n        ];\n      }\n\n      return [\n        ...memo,\n        text\n      ];\n    },\n    []\n  );\n\n  return (\n    texts\n  );\n};\n\nexport default (\n  paragraph,\n  sentenceMaxLength\n) => {\n\n  let sentences = sentencesTokenizedGet(\n    paragraph\n  );\n\n  sentences = sentencesPreprocessedGet(\n    sentences,\n    sentenceMaxLength\n  );\n  \n  sentences = sentences.reduce(\n    (\n      memo,\n      text\n    ) => {\n\n      return [\n        ...memo,\n        ...sentenceNormalizedGet(\n          text,\n          sentenceMaxLength\n        )\n      ];\n    },\n    []\n  );\n\n  return (\n    sentences\n  );\n};\n\n"],"file":"sentencesGet.js"}