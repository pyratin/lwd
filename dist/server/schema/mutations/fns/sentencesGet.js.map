{"version":3,"sources":["../../../../../js/server/schema/mutations/fns/sentencesGet.js"],"names":["sentenceMaxLength","sentenceNormalizeRegExp","sentenceCCReplace","_sentence","words","reduce","memo","tag","text","match","Set","sentence","word","replace","RegExp","trim","sentencesPreprocessedGetFn","sentencesPreprocessedGet","sentences","sentenceNormalizedGetFn","joinString","split","_text","length","sentenceNormalizedGet","texts","sentenceNormalized","slice","index","sentencesGetFn","paragraph","paragraphIndex","sbd","map","sentenceIndex","paragraphs","_paragraph","_sentences"],"mappings":"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","sourcesContent":["'use strict';\n\nimport sbd from 'sbd';\n\nimport wordsTokenizedGet from './wordsTokenizedGet';\nimport wordsTaggedGet from './wordsTaggedGet';\n\nconst sentenceMaxLength = 100;\n\nconst sentenceNormalizeRegExp = /,\\s/;\n\nconst sentenceCCReplace = (\n  _sentence\n) => {\n\n  let words = wordsTokenizedGet(\n    _sentence\n  );\n\n  words = wordsTaggedGet(\n    words\n  ); \n\n  words = words.reduce(\n    (\n      memo,\n      {\n        tag,\n        text\n      }\n    ) => {\n\n      if (\n        (\n          tag === \n          'CC'\n        ) ||\n        (\n          (\n            tag === \n            'VBG'\n          ) &&\n          (\n            text.match(\n              /ing$/\n            )\n          )\n        )\n      ) {\n\n        return [\n          ...new Set(\n            [\n              ...memo,\n              text\n            ]\n          )\n        ];\n      }\n\n      return (\n        memo\n      );\n    },\n    []\n  );\n\n  const sentence = words.reduce(\n    (\n      memo,\n      word\n    ) => {\n\n      return memo.replace(\n        new RegExp(\n          `\n            \\\\s${\n              word\n            }(\\\\s)\n          `\n            .trim(),\n          'g'\n        ),\n        `\n          , ${\n            word\n          }$1\n        `\n          .trim()\n      );\n    },\n    _sentence\n  );\n\n  return (\n    sentence\n  );\n};\n\nconst sentencesPreprocessedGetFn = (\n  _sentence\n) => {\n\n  let sentence = sentenceCCReplace(\n    _sentence\n  );\n\n  sentence = sentence.replace(\n    /\\swhich(\\s)/g,\n    ', which$1'\n  );\n\n  return (\n    sentence\n  );\n};\n\nconst sentencesPreprocessedGet = (\n  sentences\n) => {\n\n  return sentences.reduce(\n    (\n      memo,\n      _sentence\n    ) => {\n\n      const sentence = sentencesPreprocessedGetFn(\n        _sentence\n      );\n\n      return [\n        ...memo,\n        sentence\n      ];\n    },\n    []\n  );\n};\n\nconst sentenceNormalizedGetFn = (\n  text\n) => {\n\n  const joinString = ', ';\n\n  return text\n    .split(\n      sentenceNormalizeRegExp\n    )\n    .reduce(\n      (\n        memo,\n        _text\n      ) => {\n\n        switch (\n          true\n        ) {\n\n          case (\n            !memo.length\n          ) :\n\n            return [\n              _text\n            ];\n\n          case (\n            (\n              memo.length < \n              2\n            ) &&\n            (\n              memo[\n                0\n              ]\n                .length +\n              _text.length +\n              +joinString.length\n            ) < \n            sentenceMaxLength\n          ) :\n\n            return [\n              `\n                ${\n                  memo[\n                    0\n                  ]\n                    .trim()\n                }${\n                  joinString\n                }${\n                  _text.trim()\n                }\n              `\n                .trim()\n            ];\n\n          case (\n            memo.length < 2\n          ) :\n\n            return [\n              memo[\n                0\n              ],\n              _text.trim()\n            ];\n\n          default:\n\n            return [\n              memo[\n                0\n              ],\n              `\n                ${\n                  memo[\n                    1\n                  ]\n                    .trim()\n                }${\n                  joinString\n                }${\n                  _text.trim()\n                }\n              `\n                .trim()\n            ];\n        }\n      },\n      []\n    );\n};\n\nconst sentenceNormalizedGet = (\n  text\n) => {\n\n  let texts = [\n    text\n  ];\n\n  while (\n    (\n      (\n        texts[\n          texts.length - 1\n        ]\n          .length\n      ) >\n      sentenceMaxLength\n    ) &&\n    (\n      !!texts[\n        texts.length -1\n      ]\n        .match(\n          sentenceNormalizeRegExp \n        )\n    )\n  ) {\n\n    const sentenceNormalized = sentenceNormalizedGetFn(\n      texts[\n        texts.length - 1\n      ]\n    );\n\n    texts = [\n      ...texts.slice(\n        0, -1\n      ),\n      ...sentenceNormalized\n    ];\n  }\n\n  texts = texts.reduce(\n    (\n      memo,\n      text,\n      index\n    ) => {\n\n      if (\n        index <\n        (\n          texts.length - 1\n        )\n      ) {\n\n        return [\n          ...memo,\n          `\n            ${\n            text\n            } ...,\n          `\n            .trim()\n        ];\n      }\n\n      return [\n        ...memo,\n        text\n      ];\n    },\n    []\n  );\n\n  return (\n    texts\n  );\n};\n\nconst sentencesGetFn = (\n  paragraph,\n  paragraphIndex\n) => {\n\n  let sentences = sbd.sentences(\n    paragraph\n  );\n\n  sentences = sentencesPreprocessedGet(\n    sentences\n  );\n  \n  sentences = sentences.reduce(\n    (\n      memo,\n      text\n    ) => {\n\n      return [\n        ...memo,\n        ...sentenceNormalizedGet(\n          text\n        )\n      ];\n    },\n    []\n  )\n    .map(\n      (\n        text,\n        sentenceIndex\n      ) => {\n\n        return {\n          text,\n          paragraphIndex,\n          sentenceIndex\n        };\n      }\n    );\n\n  return (\n    sentences\n  );\n};\n\nexport default (\n  paragraphs\n) => {\n\n  let sentences = paragraphs.reduce(\n    (\n      memo,\n      _paragraph,\n      paragraphIndex\n    ) => {\n\n      const paragraph = _paragraph.replace(\n        /\\s*\\([^)]*\\)(\\s*)/g,\n        '$1'\n      );\n\n      const _sentences = sentencesGetFn(\n        paragraph,\n        paragraphIndex\n      );\n\n      return [\n        ...memo,\n        ..._sentences\n      ];\n    },\n    []\n  );\n\n  sentences = (\n    sentences\n  ) &&\n    sentences.reduce(\n      (\n        memo,\n        sentence\n      ) => {\n\n        if (\n          (\n            memo.length >= \n            5\n          ) &&\n          !memo[\n            memo.length - 1\n          ]\n            .text\n            .match(/\\s...,$/)\n        ) {\n\n          return (\n            memo\n          );\n        }\n\n        return [\n          ...memo,\n          sentence\n        ];\n      },\n      []\n    );\n\n  return (\n    sentences\n  );\n};\n"],"file":"sentencesGet.js"}