{"version":3,"sources":["../../../../../js/server/schema/mutations/fns/NNPCrossMatchGet.js"],"names":["characterStringMatchedGet","plotCharacter","castCharacter","characterLevenMatchedGet","characterTokenizedGet","character","map","text","characterFragmentMatchedGet","_character","characterTokenCombinations","reduce","memo","characterTokenCombination","join","characterToken","find","matchIndexString","matchIndex","parseInt","levenMatchText"],"mappings":"AAAA;;;;;;;;;;;AAEA;;AACA;;AAEA;;AAEA,IAAMA,yBAAyB,GAAG,SAA5BA,yBAA4B,CAChCC,aADgC,EAEhCC,aAFgC,EAG7B;AAEH,SACED,aAAa,KACbC,aAFK,GAIL,GAJK,GAKL,IALF;AAMD,CAXD;;AAaA,IAAMC,wBAAwB,GAAG,SAA3BA,wBAA2B,CAC/BF,aAD+B,EAE/BC,aAF+B,EAG5B;AAEH,SACE,uBACED,aADF,EAEEC,aAFF,MAGM,CAJD,GAML,GANK,GAOL,IAPF;AAQD,CAbD;;AAeA,IAAME,qBAAqB,GAAG,SAAxBA,qBAAwB,CAC5BC,SAD4B,EAEzB;AAEH,SAAO,mCACLA,SADK,EAGJC,GAHI,CAIH,gBAIK;AAAA,QAFDC,IAEC,QAFDA,IAEC;AAEH,WACEA,IADF;AAGD,GAbE,CAAP;AAeD,CAnBD;;AAqBA,IAAMC,2BAA2B,GAAG,SAA9BA,2BAA8B,CAClCH,SADkC,EAElCI,UAFkC,EAG/B;AAEH,MAAMC,0BAA0B,GAAG,8BACjCN,qBAAqB,CACnBK,UADmB,CADY,EAKhCE,MALgC,CAM/B,UACEC,IADF,EAEEC,yBAFF,EAGK;AAEH,yDACKD,IADL,IAEEC,yBAAyB,CAACC,IAA1B,CACE,GADF,CAFF;AAMD,GAjB8B,EAkB/B,EAlB+B,CAAnC;AAqBA,MAAMC,cAAc,GAAGL,0BAA0B,CAACM,IAA3B,CACrB,UACED,cADF,EAEK;AAEH,WACEA,cAAc,KACdV,SAFF;AAID,GAToB,CAAvB;AAYA,SACEU,cADK,GAGL,GAHK,GAIL,IAJF;AAKD,CA3CD;;eA6Ce,kBACbd,aADa,EAEbC,aAFa,EAGV;AAEH,MAAIe,gBAAJ;;AAEA,UACE,IADF;AAIE,SACE,CACEA,gBAAgB,GAAGjB,yBAAyB,CAC1CC,aAD0C,EAE1CC,aAF0C,CAD9C,KAMA,CAAC,CAACe,gBAPJ;AASA,SACE,CACEA,gBAAgB,GAAGd,wBAAwB,CACzCF,aADyC,EAEzCC,aAFyC,CAD7C,KAMA,CAAC,CAACe,gBAPJ;AASA,SACE,CACEA,gBAAgB,GAAGT,2BAA2B,CAC5CP,aAD4C,EAE5CC,aAF4C,CADhD,KAMA,CAAC,CAACe,gBAPJ;AASA,SACE,CACEA,gBAAgB,GAAGT,2BAA2B,CAC5CN,aAD4C,EAE5CD,aAF4C,CADhD,KAMA,CAAC,CAACgB,gBAPJ;AAUE,aACE;AACEV,QAAAA,IAAI,EAAEN,aADR;AAEEiB,QAAAA,UAAU,EAAEC,QAAQ,CAClBF,gBADkB,CAFtB;AAKEG,QAAAA,cAAc,EACZD,QAAQ,CACNF,gBADM,CAAR,KAGA,CAJc,GAMdf,aANc,GAOd;AAZJ,OADF;AAzCJ;AA0DD,C","sourcesContent":["'use strict';\n\nimport leven from 'leven';\nimport combinations from 'combinations';\n\nimport wordsTokenizedGet from './wordsTokenizedGet';\n\nconst characterStringMatchedGet = (\n  plotCharacter,\n  castCharacter\n) => {\n\n  return (\n    plotCharacter ===\n    castCharacter\n  ) ?\n    '0' :\n    null;\n};\n\nconst characterLevenMatchedGet = (\n  plotCharacter,\n  castCharacter\n) => {\n\n  return (\n    leven(\n      plotCharacter,\n      castCharacter\n    ) === 1\n  ) ?\n    '1' :\n    null;\n};\n\nconst characterTokenizedGet = (\n  character\n) => {\n\n  return wordsTokenizedGet(\n    character\n  )\n    .map(\n      (\n        {\n          text\n        }\n      ) => {\n\n        return (\n          text\n        );\n      }\n    );\n};\n\nconst characterFragmentMatchedGet = (\n  character,\n  _character\n) => {\n\n  const characterTokenCombinations = combinations(\n    characterTokenizedGet(\n      _character\n    )\n  )\n    .reduce(\n      (\n        memo,\n        characterTokenCombination\n      ) => {\n\n        return [\n          ...memo,\n          characterTokenCombination.join(\n            ' '\n          )\n        ];\n      },\n      []\n    );\n\n  const characterToken = characterTokenCombinations.find(\n    (\n      characterToken\n    ) => {\n\n      return (\n        characterToken ===\n        character\n      );\n    }\n  );\n\n  return (\n    characterToken\n  ) ?\n    '2' :\n    null;\n};\n\nexport default (\n  plotCharacter,\n  castCharacter\n) => {\n\n  let matchIndexString;\n\n  switch (\n    true\n  ) {\n\n    case (\n      (\n        matchIndexString = characterStringMatchedGet(\n          plotCharacter,\n          castCharacter\n        )\n      ) &&\n      !!matchIndexString\n    ) :\n    case (\n      (\n        matchIndexString = characterLevenMatchedGet(\n          plotCharacter,\n          castCharacter\n        )\n      ) &&\n      !!matchIndexString\n    ) :\n    case (\n      (\n        matchIndexString = characterFragmentMatchedGet(\n          plotCharacter,\n          castCharacter,\n        )\n      ) &&\n      !!matchIndexString\n    ) :\n    case (\n      (\n        matchIndexString = characterFragmentMatchedGet(\n          castCharacter,\n          plotCharacter,\n        )\n      ) &&\n      !!matchIndexString\n    ) :\n\n      return (\n        {\n          text: plotCharacter,\n          matchIndex: parseInt(\n            matchIndexString\n          ),\n          levenMatchText: (\n            parseInt(\n              matchIndexString\n            ) === \n            1\n          ) ?\n            castCharacter :\n            null\n        }\n      );\n  }\n};\n"],"file":"NNPCrossMatchGet.js"}